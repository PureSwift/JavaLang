// Auto-generated by Java-to-Swift wrapper generator.
import CSwiftJavaJNI
import JavaUtilFunction
import SwiftJava

@JavaInterface("java.util.Map")
public struct Map<K: AnyJavaObject, V: AnyJavaObject> {
  /// Java method `remove`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)
  /// ```
@JavaMethod
  public func remove(_ arg0: JavaObject?, _ arg1: JavaObject?) -> Bool

  /// Java method `remove`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract V java.util.Map.remove(java.lang.Object)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func remove(_ arg0: JavaObject?) -> V!

  /// Java method `size`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract int java.util.Map.size()
  /// ```
@JavaMethod
  public func size() -> Int32

  /// Java method `get`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract V java.util.Map.get(java.lang.Object)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func get(_ arg0: JavaObject?) -> V!

  /// Java method `put`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract V java.util.Map.put(K,V)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func put(_ arg0: K?, _ arg1: V?) -> V!

  /// Java method `equals`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract boolean java.util.Map.equals(java.lang.Object)
  /// ```
@JavaMethod
  public func equals(_ arg0: JavaObject?) -> Bool

  /// Java method `values`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract java.util.Collection<V> java.util.Map.values()
  /// ```
@JavaMethod
  public func values() -> JavaCollection<V>!

  /// Java method `hashCode`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract int java.util.Map.hashCode()
  /// ```
@JavaMethod
  public func hashCode() -> Int32

  /// Java method `clear`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract void java.util.Map.clear()
  /// ```
@JavaMethod
  public func clear()

  /// Java method `isEmpty`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract boolean java.util.Map.isEmpty()
  /// ```
@JavaMethod
  public func isEmpty() -> Bool

  /// Java method `replace`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default boolean java.util.Map.replace(K,V,V)
  /// ```
@JavaMethod
  public func replace(_ arg0: K?, _ arg1: V?, _ arg2: V?) -> Bool

  /// Java method `replace`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.replace(K,V)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func replace(_ arg0: K?, _ arg1: V?) -> V!

  /// Java method `replaceAll`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
  /// ```
@JavaMethod
  public func replaceAll(_ arg0: JavaBiFunction<JavaObject, JavaObject, V>?)

  /// Java method `merge`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func merge(_ arg0: K?, _ arg1: V?, _ arg2: JavaBiFunction<JavaObject, JavaObject, V>?) -> V!

  /// Java method `entrySet`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract java.util.Set<java.util.Map$Entry<K, V>> java.util.Map.entrySet()
  /// ```
@JavaMethod
  public func entrySet() -> JavaSet<Map<K, V>.Entry>!

  /// Java method `putAll`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract void java.util.Map.putAll(java.util.Map<? extends K, ? extends V>)
  /// ```
@JavaMethod
  public func putAll(_ arg0: Map<K, V>?)

  /// Java method `putIfAbsent`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.putIfAbsent(K,V)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func putIfAbsent(_ arg0: K?, _ arg1: V?) -> V!

  /// Java method `compute`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func compute(_ arg0: K?, _ arg1: JavaBiFunction<JavaObject, JavaObject, V>?) -> V!

  /// Java method `computeIfAbsent`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func computeIfAbsent(_ arg0: K?, _ arg1: JavaFunction<JavaObject, V>?) -> V!

  /// Java method `forEach`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)
  /// ```
@JavaMethod
  public func forEach(_ arg0: JavaBiConsumer<JavaObject, JavaObject>?)

  /// Java method `keySet`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract java.util.Set<K> java.util.Map.keySet()
  /// ```
@JavaMethod
  public func keySet() -> JavaSet<K>!

  /// Java method `containsValue`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract boolean java.util.Map.containsValue(java.lang.Object)
  /// ```
@JavaMethod
  public func containsValue(_ arg0: JavaObject?) -> Bool

  /// Java method `containsKey`.
  ///
  /// ### Java method signature
  /// ```java
  /// public abstract boolean java.util.Map.containsKey(java.lang.Object)
  /// ```
@JavaMethod
  public func containsKey(_ arg0: JavaObject?) -> Bool

  /// Java method `getOrDefault`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.getOrDefault(java.lang.Object,V)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func getOrDefault(_ arg0: JavaObject?, _ arg1: V?) -> V!

  /// Java method `computeIfPresent`.
  ///
  /// ### Java method signature
  /// ```java
  /// public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)
  /// ```
@JavaMethod(typeErasedResult: "V!")
  public func computeIfPresent(_ arg0: K?, _ arg1: JavaBiFunction<JavaObject, JavaObject, V>?) -> V!
}
extension JavaClass {
  /// Java method `copyOf`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.copyOf(java.util.Map<? extends K, ? extends V>)
  /// ```
@JavaStaticMethod
  public func copyOf<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: Map<K, V>?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of()
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>() -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?, _ arg8: K?, _ arg9: V?, _ arg10: K?, _ arg11: V?, _ arg12: K?, _ arg13: V?, _ arg14: K?, _ arg15: V?, _ arg16: K?, _ arg17: V?, _ arg18: K?, _ arg19: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?, _ arg8: K?, _ arg9: V?, _ arg10: K?, _ arg11: V?, _ arg12: K?, _ arg13: V?, _ arg14: K?, _ arg15: V?, _ arg16: K?, _ arg17: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?, _ arg8: K?, _ arg9: V?, _ arg10: K?, _ arg11: V?, _ arg12: K?, _ arg13: V?, _ arg14: K?, _ arg15: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?, _ arg8: K?, _ arg9: V?, _ arg10: K?, _ arg11: V?, _ arg12: K?, _ arg13: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?, _ arg8: K?, _ arg9: V?, _ arg10: K?, _ arg11: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `of`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.of(K,V,K,V,K,V,K,V,K,V)
  /// ```
@JavaStaticMethod
  public func of<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?, _ arg2: K?, _ arg3: V?, _ arg4: K?, _ arg5: V?, _ arg6: K?, _ arg7: V?, _ arg8: K?, _ arg9: V?) -> Map<K, V>! where ObjectType == Map<K, V>

  /// Java method `entry`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map$Entry<K, V> java.util.Map.entry(K,V)
  /// ```
@JavaStaticMethod
  public func entry<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: K?, _ arg1: V?) -> Map<K, V>.Entry! where ObjectType == Map<K, V>

  /// Java method `ofEntries`.
  ///
  /// ### Java method signature
  /// ```java
  /// public static <K,V> java.util.Map<K, V> java.util.Map.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)
  /// ```
@JavaStaticMethod
  public func ofEntries<K: AnyJavaObject, V: AnyJavaObject>(_ arg0: [Map<K, V>.Entry?]) -> Map<K, V>! where ObjectType == Map<K, V>
}
